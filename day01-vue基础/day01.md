## 谈谈 MVVM

M：Model，数据层（data、计算属性、监视属性等）

V：View，视图层（HTML）

VM：ViewModel，视图模型层

当视图层要渲染绑定的数据时，VM负责把Model中对应绑定的数据渲染到View

当视图层绑定的数据发生变化时，VM负责绑定事件，从事件中读取View层修改的数据，再去Model层中修改对应的数据

## 谈谈插值语法

插值语法使用{{}}表示，在{{}}中只能书写JS表达式，不能书写语句，并且插值表达式只能书写在dom元素的子节点中，不能书写在dom元素的属性上。

表达式有返回值，并且没有以分号结尾；语句没有返回值，并且以分号结尾，但是分号可以省略。

## 谈谈指令语法（哪些、怎么使用、作用）

v-model：双向数据绑定

- 绑定input标签的value值（所以一上来input就有内容显示）
- 绑定input标签的input事件（当input输入的值发生变化，会自动修改绑定的data数据）
- 只能用于表单项：input、select、textarea

v-bind：强制数据绑定（单向数据绑定，Model的数据流向View）

- 功能：给标签属性绑定某个动态数据
- 简写：`:属性名`

v-on：绑定事件监听

- 功能：用于绑定DOM事件
- 事件回调函数定义在配置对象中的methods中
- 简写：`@事件名="事件回调函数"`，当事件回调函数中只有一条语句时，可以不在methods中定义回调函数，直接简写成`@事件名="本来在回调函数中书写的语句"`，但注意不能在语句中书写this，自己会自动去this上寻找对应使用的数据

v-if和v-show条件渲染

- v-if
  - v-if
  - v-else-if
  - v-else
- v-show

> v-if和v-show
>
> - 相同点：都能切换显示
> - 不同点：
>   - v-if隐藏元素时会删除对应的dom元素
>   - v-show隐藏元素时是通过display:none隐藏的，不会删除dom元素
>
> v-show的性能比v-if更好，当频繁切换时使用v-show较好

v-for列表渲染

- 数组：`v-for="(item[,index]) in items"`必须有一个参数，即代表当前项，支持第二个可选参数，即代表当前项的索引，可以省略小括号
- 对象：`v-for="value[,key,index] in obj"`必须有一个测试，即代表当前项的值，支持第二个可选参数，即代表当前项的键名，支持第三个可选参数，即代表当前项的索引。在遍历对象时，会按`Object.keys()`的结果遍历，但是不能保证它的结果在不同的JavaScript引擎下都一致

## 谈谈计算属性和监视属性

当需要通过原属性计算得到一个新数据，那么使用计算属性，计算属性里面不能做异步操作

1. 只读的计算属性和可读可写的计算属性
2. 计算属性有缓存，如果依赖的数据没有发生变化，是不会重新计算的，只有依赖的数据发生了变化，才会重新计算（依赖的数据指的是读取方法中使用的this上的数据）

当需要通过原属性的变化来干一些事，就用监视属性

计算属性和监视属性的异同点

1. 能用计算属性做的，都可以使用监视属性，但是推荐使用计算属性
2. 涉及到异步操作只能使用监视属性

## 谈谈原型
- 原型指的是两个原型属性：
  - prototype 显示原型属性
  - `__proto__` 隐式原型属性

- 每个函数都有显示原型属性（箭头函数没有），它的值是一个对象，我们叫原型对象
  - 这个原型对象有一个属性 contructor，他指向函数本身
  - 这个原型对象还有一个属性 `__proto__`，他指向Object.prototype

- 每个对象都有隐藏原型属性，它的值是一个对象，指向其构造函数的显示原型属性

- 所有数组都是 new Array产生的，所以数组的隐藏原型指向Array的显示原型
  - Array的显示原型就有n个数组的方法，比如：filter map reduce sort
  - 所以数组就能继承得到这些方法

- 所有函数都是 new Function产生的，所以函数的隐藏原型指向Function的显示原型  
  - Function的显示原型就有n个函数的方法，比如：call apply bind
  - 所以函数就能继承得到这些方法

- 特殊：
  - Function可以看做是new Function产生的
    - `Function.__proto__ === Function.ptototype`
  - `Object.prototype.__proto__ === null` 这是原型链的终点

- 原型链
  - 作用：对象查找属性的规则
  - 规则：先在自身属性上找，找到了直接返回值，没有找到就沿着`__proto__`找，直到找到`Object.prototype.__proto__`，返回值undefined

- 原型和原型链
  - 最终目的就为了继承（复用代码）

